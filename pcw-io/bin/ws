#!/usr/bin/env node

/**
 * Module dependencies.
 */
const config = require('dotenv').config();
const debug = require("debug")("pcw");
const http = require("http");
const url = require("url");
const path = require("path");
const fs = require("fs");
const WebSocketServer = require("ws").Server;
const port = normalizePort(process.env.PORT || "3000");
const PianoBar = require("../lib/PianoBar");
const childProcess = require("child_process");
const BIN_DIR = path.join(__dirname);

// WebSocket Server reference
let wss;
let lastStats = null;
let currentStations = [];
let currentStation = null;
let currentSong = {};

const PCW_HOME = process.env.PCW_HOME || process.env.HOME || '/tmp';

if(!PCW_HOME || PCW_HOME === '/tmp') {
    console.error('No PCW_HOME is set');
    process.exit(1);
} else if(!fs.existsSync(PCW_HOME)) {
    console.error('PCW_HOME directory ' + PCW_HOME + ' does not exist!');
    process.exit(1);
} else {
    debug('PCW_HOME set to ' + PCW_HOME);
}

const pb = new PianoBar({
    cwd: PCW_HOME
});

debug('Initializing stations...');
pb.readStations((err, res) => {
    if (!err) {
        currentStations = res.stations;
    } else {
        console.error("Cannot read stations", err);
    }
});

const generateGUID = function guid() {
    function s4() {
        return Math.floor((1 + Math.random()) * 0x10000)
            .toString(16)
            .substring(1);
    }

    return `${s4()}${s4()}-${s4()}-${s4()}${s4()}${s4()}`;
};

const broadcastUpdate = function broadcastUpdate() {
    pb.readStats(function(err, stats) {
        if (err) {
            console.error(err);
            debug(err);
            return;
        }

        let data = {
            ts: Date.now().toString(),
            stats: stats
        };

        wss.broadcast(JSON.stringify(data));
    });
};

const startPianoBar = function startPianoBar() {
    let command = "bash " + path.join(BIN_DIR, "pbctl.sh") + " start";
    let pianobar = childProcess.exec(command, function(error, stdout, stderr) {
        if (stdout) {
            process.stdout.write(stdout);
        }
        if (stderr) {
            process.stderr.write(stderr);
        }
        if (error) {
            console.error(error.message);
            debug(error.message, error);
        }
    });

    pianobar.on("exit", function(code) {
        if (code !== 0) {
            console.error("Could not start pianobar process");
            wss.broadcast(JSON.stringify({ event: 'pianobar-error', error: true, message: 'Could not start Pianobar process', running: false }));
        } else {
            pb.stopped = false;
            pb.paused = false;
            wss.broadcast(JSON.stringify({ event: 'pianobar-start', running: true, stopped: false, paused: false, playing: true }));
        }
    });
};

const stopPianoBar = function stopPianoBar() {
    try {
        let command = "bash " + path.join(BIN_DIR, "pbctl.sh") + " stop";
        debug(command);
        let pianobar = childProcess.exec(command, function(
            error,
            stdout,
            stderr
        ) {
            if (stdout) {
                process.stdout.write(stdout);
            }
            if (stderr) {
                process.stderr.write(stderr);
            }
            if (error) {
                console.error(error.message);
                debug(error.message, error);
            }
        });

        pianobar.on("exit", function(code) {
            if (code !== 0) {
                console.error("Could not stop pianobar process");
            } else {
                pb.stopped = true;
                pb.paused = false;
                wss.broadcast(JSON.stringify({event: 'pianobar-stop', running: false, stopped: true, paused: false, playing: false }));
            }
        });
    } catch (ex) {
        console.error(ex.message);
        debug(ex);
    }
};

const handleJsonReq = function(request, callback) {
    let body = "";
    request.on("data", chunk => {
        body += chunk.toString();
    });

    request.on("end", () => {
        try {
            const json = JSON.parse(body);
            return callback(null, json);
        } catch (err) {
            console.error("Error parsing body: " + err.message, { body });
            return callback(err);
        }
    });

    request.on("error", err => {
        console.error("Error handling request", err);
        return callbacK(err);
    });
};

const selectCurrentStation = function selectCurrentStation(stationTitle) {
    if (!stationTitle) {
        currentStation = null;
    } else if (!currentStation || currentStation.title !== stationTitle) {
        for (let i = 0; i < currentStations.length; i++) {
            const s = currentStations[i];
            if (s.name === stationTitle || s.title === stationTitle) {
                currentStation = {
                    index: i,
                    title: stationTitle,
                    name: s.name
                };

                debug("Changing current station to '" + stationTitle + "'", {
                    ...currentStation
                });
                break;
            }
        }
    }
};

const handleSongStart = function handleSongStart(req) {
    debug("Song Start");
    handleJsonReq(req, (err, body) => {
        if (!err) {
            currentSong = {
                title: body.title,
                artist: body.artist,
                album: body.album,
                coverArt: body.coverArt,
                rating: Number.parseInt(body.rating || 0),
                songDuration: Number.parseInt(body.songDuration || 0),
                songPlayed: Number.parseInt(body.songPlayed || 0),
                station: body.station
            };

            selectCurrentStation(currentSong.station);
        }
    });
};

const handleSongFinish = function handleSongFinish(req) {
    debug("Song Finish");
    handleJsonReq(req, (err, body) => {
        if (!err && !!currentSong) {
            currentSong.songPlayed = Number.parseInt(body.songPlayed || 0);
            currentSong.rating = Number.parseInt(body.rating || 0);
        } else if (!currentSong) {
            debug("Received Song Finish with no current song", body);
        }
    });
};

const handleUserLogin = function handleUserLogin(req) {
    handleJsonReq(req, (err, body) => {
        if (!err) {
            debug("UserLogin", body);
        }
    });
};

const handlePianobarEvent = function handlePianobarEvent(req) {
    handleJsonReq(req, (err, body) => {
        if (!err) {
            debug("Event", body);
            console.log('Event', body);
        }
    });
};

const handleUserGetStations = function handleUserGetStations(req) {
    handleJsonReq(req, (err, body) => {
        if (!err) {
            debug("Stations", body);
            console.log('Stations', body);
        }
    });
};

const handlePianobarError = function handlePianobarError(req) {
    handleJsonReq(req, (err, body) => {
        if (!err) {
            console.error('Pianobar Error', body);
            debug("Pianobar Error", body);
        } else {
            console.error(err);
        }
    });
};

/**
 * Create HTTP server.
 */
const server = http.createServer(function(req, res) {
    let reqUrl = req.url;
    if (reqUrl.includes("favicon")) {
        res.statusCode = 200;
        res.write("");
        return res.end();
    }

    let method = req.method;

    let found = false;
    let statusCode = 200;
    let resBody = "";
    res.setHeader("Cache-Control", "no-cache");

    if (method === "POST") {
        shouldBroadcastUpdate = true;
        switch (reqUrl) {
            case "/songstart":
                handleSongStart(req);
                break;
            case "/songfinish":
                handleSongFinish(req);
                break;
            case "/userlogin":
                handleUserLogin(req);
                break;
            case "/usergetstations":
                handleUserGetStations(req);
                break;
            case "/pbevent":
                shouldBroadcastUpdate = handlePianobarEvent(req);
                break;
            case "/pberr":
                shouldBroadcastUpdate = false;
                handlePianobarError(req);
                break;
            case "/bcast":
                break;
            default:
                shouldBroadcastUpdate = false;
                found = false;
                resBody = "Not Found";
                statusCode = 404;
                break;
        }

        if (shouldBroadcastUpdate) {
            broadcastUpdate();
        }
    } else if (method === "GET") {
        res.setHeader("Content-Type", "application/json; charset=utf-8");
        if (reqUrl === "/stats") {
            found = true;
            resBody = JSON.stringify({
                stats: lastStats
            });
        }
    }

    if (!found) {
        res.statusCode = 404;
    } else {
        res.statusCode = statusCode;
    }

    debug(res.statusCode + " " + method + ": " + reqUrl);

    res.write(resBody);
    return res.end();
});

/**
 * Listen on provided port, on all network interfaces.
 */
server.listen(port);
server.on("error", onError);
server.on("listening", onListening);

wss = new WebSocketServer({ server: server });
wss.broadcast = function broadcast(data) {
    wss.clients.forEach(function each(client) {
        client.send(data);
    });
};

wss.on("connection", function connection(ws) {
    let guid = generateGUID();
    ws.send(
        JSON.stringify({
            event: "connected",
            id: guid,
            ts: Date.now().toString(),
            stations: currentStations,
            // TODO: Stateful status
            running: pb.running()
        })
    );

    ws.on("open", function open() {
        ws.send(Date.now().toString(), { mask: true });
    });

    ws.on("close", function() {});

    ws.on("message", function(data, flags) {
        let json = JSON.parse(data);
        let event = json.event;

        if (event === "current-status") {
            let stats = pb.readStatsSync();
            let isRunning = !pb.stopped;
            ws.send(
                JSON.stringify({
                    event: "current-stats",
                    stats: stats,
                    running: isRunning
                })
            );
        } else if (event === "skip") {
            pb.skip(function(err) {
                if (err) {
                    console.error(err);
                }
            });
        } else if (event === "like") {
            pb.like(function(err) {
                if (err) {
                    console.error(err);
                }
            });
        } else if (event === "ban") {
            pb.ban(function(err) {
                if (err) {
                    console.error(err);
                }
            });
        } else if (event === "pause-toggle") {
            pb.pauseToggle(function(err) {
                if (err) {
                    console.error(err);
                }
            });
        } else if (event === "change-station") {
            let station = json.stationName;
            if (!station) {
                console.error("No station to change to", json);
                return;
            }

            pb.changeStation(station, function(err) {
                if (err) {
                    console.error(err);
                }
            });
        } else if (event === "next-station") {
            pb.nextStation(function(err) {
                if (err) {
                    console.error(err);
                }
            });
        } else if (event === "start") {
            startPianoBar();
        } else if (event === "stop") {
            stopPianoBar();
        } else if (event === "start-stop") {
            if (pb.stopped) {
                startPianoBar();
            } else {
                stopPianoBar();
            }
        }
    });
});

/**
 * Normalize a port into a number, string, or false.
 */
function normalizePort(val) {
    let port = parseInt(val, 10);

    if (isNaN(port)) {
        // named pipe
        return val;
    }

    if (port >= 0) {
        // port number
        return port;
    }

    return false;
}

/**
 * Event listener for HTTP server "error" event.
 */
function onError(error) {
    if (error.syscall !== "listen") {
        throw error;
    }

    let bind = typeof port === "string" ? "Pipe " + port : "Port " + port;

    // handle specific listen errors with friendly messages
    switch (error.code) {
        case "EACCES":
            console.error(bind + " requires elevated privileges");
            process.exit(1);
            break;
        case "EADDRINUSE":
            console.error(bind + " is already in use");
            process.exit(1);
            break;
        default:
            throw error;
    }
}

/**
 * Event listener for HTTP server "listening" event.
 */
function onListening() {
    let addr = server.address();
    let bind = typeof addr === "string" ? "pipe " + addr : "port " + addr.port;
    debug("Listening on " + bind);
}

function shutdown() {
    stopPianoBar();
}

process.on("exit", function() {
    debug("Shutting down...");
    shutdown();
    process.exit(0);
});

process.on("SIGINT", function() {
    debug("Shutting down due to interruption...");
    shutdown();
    process.exit(0);
});

process.on("uncaughtException", function(e) {
    // console.error("Shutting down due to uncaught exception...");
    console.error('ERROR: ' + e.message);
    if(e.stack) {
        console.error(e.stack);
    }
    debug("UncaughtException: " + e.message, e.stack);
    // debug(e.stack);
    // process.abort();
});
