#!/usr/bin/env node

/**
 * Module dependencies.
 */
const debug = require("debug")("pcw");
const http = require("http");
const url = require("url");
const path = require("path");
const fs = require("fs");
const WebSocketServer = require("ws").Server;
const port = normalizePort(process.env.PORT || "3000");
const PianoBar = require("../lib/PianoBar");
// const BatteryStats = require("../lib/BatteryStats");
const childProcess = require("child_process");
const BIN_DIR = path.join(__dirname);
let lastStats = null;
// let lastBatteryStats = null;

const pb = new PianoBar({
    cwd: "/Users/mustafa/.config/pianobar"
});

let wss;

const generateGUID = function guid() {
    function s4() {
        return Math.floor((1 + Math.random()) * 0x10000)
            .toString(16)
            .substring(1);
    }
    return (
        s4() +
        s4() +
        "-" +
        s4() +
        "-" +
        s4() +
        "-" +
        s4() +
        "-" +
        s4() +
        s4() +
        s4()
    );
};

const broadcastUpdate = function broadcastUpdate() {
    pb.readStats(function(err, stats) {
        if (err) {
            console.error(err);
            debug(err);
            return;
        }

        let data = {
            ts: Date.now().toString(),
            stats: stats
        };

        wss.broadcast(JSON.stringify(data));
    });
};

// const batteryStatsBroadcast = function(stats) {
//     if (batteryStatsRequireUpdate(stats)) {
//         lastBatteryStats = stats;

//         let data = {
//             ts: Date.now().toString(),
//             stats: stats,
//             event: "battery-stats"
//         };
//         wss.broadcast(JSON.stringify(data));
//     }
// };

// const bs = new BatteryStats({ stats_cb: batteryStatsBroadcast });

const startPianoBar = function startPianoBar() {
    let command = "bash " + path.join(BIN_DIR, "pbctl.sh") + " start";
    let pianobar = childProcess.exec(command, function(error, stdout, stderr) {
        if (stdout) {
            process.stdout.write(stdout);
        }
        if (stderr) {
            process.stderr.write(stderr);
        }
        if (error) {
            console.error(error.message);
            debug(error.message, error);
        }
    });

    pianobar.on("exit", function(code) {
        if (code !== 0) {
            console.error("Could not start pianobar process");
        } else {
            pb.stopped = false;
            pb.paused = false;
        }
    });
};

const stopPianoBar = function stopPianoBar() {
    try {
        let command = "bash " + path.join(BIN_DIR, "pbctl.sh") + " stop";
        debug(command);
        let pianobar = childProcess.exec(command, function(
            error,
            stdout,
            stderr
        ) {
            if (stdout) {
                process.stdout.write(stdout);
            }
            if (stderr) {
                process.stderr.write(stderr);
            }
            if (error) {
                console.error(error.message);
                debug(error.message, error);
            }
        });

        pianobar.on("exit", function(code) {
            if (code !== 0) {
                console.error("Could not stop pianobar process");
            } else {
                pb.stopped = true;
                pb.paused = true;
            }
        });
    } catch (ex) {
        console.error(ex.message);
        debug(ex);
    }
};

/**
 * Create HTTP server.
 */
const server = http.createServer(function(req, res) {
    let reqUrl = req.url;
    if (reqUrl.includes("favicon")) {
        res.statusCode = 200;
        res.write("");
        return res.end();
    }

    let method = req.method;

    let found = false;
    let statusCode = 200;
    let resBody = "";
    res.setHeader("Cache-Control", "no-cache");

    if (method === "POST") {
        if (reqUrl === "/songstart") {
            resBody = "ok";
            found = true;
            broadcastUpdate();
        } else if(reqUrl == "/bcast") {
            resBody = "ok";
            found = true;
            broadcastUpdate();
        }
        // } else if (reqUrl == "/battery") {
        //     resBody = "ok";
        //     found = true;
        //     batteryStats();
        // }
    } else if (method === "GET") {
        if (reqUrl === "/stats") {
            let = stats = pb.readStatsSync();

            found = true;
            resBody = JSON.stringify({
                stats: stats
                // battery: bs.getCurrentStats()
            });
            res.setHeader("Content-Type", "application/json; charset=utf-8");
        }
    }

    if (!found) {
        res.statusCode = 404;
    } else {
        res.statusCode = statusCode;
    }

    debug(res.statusCode + " " + method + ": " + reqUrl);

    res.write(resBody);
    return res.end();
});

/**
 * Listen on provided port, on all network interfaces.
 */
server.listen(port);
server.on("error", onError);
server.on("listening", onListening);

wss = new WebSocketServer({ server: server });
wss.broadcast = function broadcast(data) {
    wss.clients.forEach(function each(client) {
        client.send(data);
    });
};

const statsRequireUpdate = function statsRequireUpdate(freshStats) {
    if (!freshStats) {
        return false;
    }
    if (!lastStats) {
        return true;
    }
    return !(
        freshStats.title == lastStats.title &&
        freshStats.stopped == !lastStats.running &&
        freshStats.paused == lastStats.paused
    );
};

// const batteryStatsRequireUpdate = function batteryStatsRequireUpdate(s) {
//     if (!s) {
//         return false;
//     }
//     if (!lastBatteryStats) {
//         return true;
//     }
//     return !(
//         s.has_battery == lastBatteryStats.has_battery &&
//         s.percentage == lastBatteryStats.percentage &&
//         s.is_charging == lastBatteryStats.is_charging
//     );
// };

const broadcastStats = function broadcastStats() {
    pb.running();
    let stats = pb.readStatsSync();
    let isRunning = !pb.stopped;

    if (statsRequireUpdate(stats)) {
        lastStats = stats;
        lastStats.running = isRunning;
        wss.broadcast(
            JSON.stringify({
                event: "current-stats",
                stats: stats,
                running: isRunning
            })
        );
    }
};

const broadcastIntervalId = setInterval(broadcastStats, 500);

// let batteryStatsIntervalId;
// const batteryStats = function batteryStats() {
//     // bs.getBatteryStats(function(err, stats) {
//     //     if (err) {
//     //         console.error(err);
//     //         debug("Battery stats error", err);
//     //         clearInterval(batteryStatsIntervalId);
//     //     }
//     // });
// };
// // batteryStatsIntervalId = setInterval(batteryStats, 500);

wss.on("connection", function connection(ws) {
    let guid = generateGUID();
    ws.send(
        JSON.stringify({
            event: "connected",
            id: guid,
            ts: Date.now().toString(),
            stations: pb.readStationsSync(),
            running: pb.running()
        })
    );

    // ws.send(
    //     JSON.stringify({
    //         event: "battery-stats",
    //         id: guid,
    //         ts: Date.now().toString(),
    //         stats: lastBatteryStats
    //     })
    // );

    ws.on("open", function open() {
        ws.send(Date.now().toString(), { mask: true });
    });

    ws.on("close", function() {});

    ws.on("message", function(data, flags) {
        let json = JSON.parse(data);
        let event = json.event;

        if (event === "current-status") {
            let stats = pb.readStatsSync();
            let isRunning = !pb.stopped;
            ws.send(
                JSON.stringify({
                    event: "current-stats",
                    stats: stats,
                    running: isRunning
                })
            );
        } else if (event === "skip") {
            pb.skip(function(err) {
                if (err) {
                    console.error(err);
                }
            });
        } else if (event === "like") {
            pb.like(function(err) {
                if (err) {
                    console.error(err);
                }
            });
        } else if (event === "ban") {
            pb.ban(function(err) {
                if (err) {
                    console.error(err);
                }
            });
        } else if (event === "pause-toggle") {
            pb.pauseToggle(function(err) {
                if (err) {
                    console.error(err);
                }
            });
        } else if (event === "change-station") {
            let station = json.data.stationName;
            if (!station) {
                console.error("No station to change to", json);
                return;
            }

            pb.changeStation(station, function(err) {
                if (err) {
                    console.error(err);
                }
            });
        } else if (event === "next-station") {
            pb.nextStation(function(err) {
                if (err) {
                    console.error(err);
                }
            });
        } else if (event === "start") {
            startPianoBar();
        } else if (event === "stop") {
            stopPianoBar();
        } else if (event === "start-stop") {
            if (pb.stopped) {
                startPianoBar();
            } else {
                stopPianoBar();
            }
        }
    });
});

/**
 * Normalize a port into a number, string, or false.
 */
function normalizePort(val) {
    let port = parseInt(val, 10);

    if (isNaN(port)) {
        // named pipe
        return val;
    }

    if (port >= 0) {
        // port number
        return port;
    }

    return false;
}

/**
 * Event listener for HTTP server "error" event.
 */
function onError(error) {
    if (error.syscall !== "listen") {
        throw error;
    }

    let bind = typeof port === "string" ? "Pipe " + port : "Port " + port;

    // handle specific listen errors with friendly messages
    switch (error.code) {
        case "EACCES":
            console.error(bind + " requires elevated privileges");
            process.exit(1);
            break;
        case "EADDRINUSE":
            console.error(bind + " is already in use");
            process.exit(1);
            break;
        default:
            throw error;
    }
}

/**
 * Event listener for HTTP server "listening" event.
 */
function onListening() {
    let addr = server.address();
    let bind = typeof addr === "string" ? "pipe " + addr : "port " + addr.port;
    debug("Listening on " + bind);
}

function shutdown() {
    stopPianoBar();
}

process.on("exit", function() {
    debug("Shutting down...");
    shutdown();
    process.exit(0);
});

process.on("SIGINT", function() {
    debug("Shutting down due to interruption...");
    shutdown();
    process.exit(0);
});

process.on("uncaughtException", function(e) {
    console.error("Shutting down due to uncaught exception...");
    console.error(e.message);
    console.error(e.stack);
    debug("UncaughtException: " + e.message);
    debug(e.stack);
    process.abort();
});
