#!/usr/bin/env node

/**
 * Module dependencies.
 */
const debug = require('debug')('pcw');
const http = require('http');
const url = require('url');
const path = require('path');
const fs = require('fs');
const WebSocketServer = require('ws').Server;
const port = normalizePort(process.env.PORT || '3000');
const PianoBar = require('../lib/PianoBar');
const BatteryStats = require('../lib/BatteryStats');
const childProcess = require('child_process');
const BIN_DIR = path.join(__dirname);
let lastStats = null;
let lastBatteryStats = null;

const pb = new PianoBar();

let wss;

const generateGUID = function guid() {
  function s4() {
    return Math.floor((1 + Math.random()) * 0x10000)
        .toString(16)
        .substring(1);
  }
  return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
         s4() + '-' + s4() + s4() + s4();
};


const broadcastUpdate = function broadcastUpdate() {
  pb.readStats(function(err, stats){
    if(err) {
      console.error(err);
      debug(err);
      return;
    }

    let data = {
      ts: Date.now().toString(),
      stats: stats
    };

    wss.broadcast(JSON.stringify(data));
  });
};

const batteryStatsBroadcast = function(stats) {
  if(batteryStatsRequireUpdate(stats)) {
    lastBatteryStats = stats;

    let data = {
        ts: Date.now().toString(),
        stats: stats,
        event: 'battery-stats'
    };
    wss.broadcast(JSON.stringify(data));
  }
};

const bs = new BatteryStats({ stats_cb: batteryStatsBroadcast });

const startPianoBar = function startPianoBar() {
  let command = 'bash ' + path.join(BIN_DIR, 'pbctl.sh') + ' start';
  let pianobar = childProcess.exec(command, function(error, stdout, stderr){
    if(stdout){ process.stdout.write(stdout); }
    if(stderr){ process.stderr.write(stderr); }
    if(error) {
      console.error(error.message);
      debug(error.message, error);
    }
  });

  pianobar.on('exit', function(code){
    if(code !== 0){ console.error('Could not start pianobar process'); }
    else {
      pb.stopped = false;
      pb.paused = false;
    }
  });
};

const stopPianoBar = function stopPianoBar() {
  try {
    let command = 'bash ' + path.join(BIN_DIR, 'pbctl.sh') + ' stop';
    debug(command);
    let pianobar = childProcess.exec(command,
       function (error, stdout, stderr) {

         if(stdout){ process.stdout.write(stdout); }
         if(stderr){ process.stderr.write(stderr); }
         if(error) {
           console.error(error.message);
           debug(error.message, error);
         }
       });

    pianobar.on('exit', function(code){
      if(code !== 0){ console.error('Could not stop pianobar process'); }
      else {
        pb.stopped = true;
        pb.paused = true;
      }
    });
  }
  catch(ex) {
    console.error(ex.message);
    debug(ex);
  }
};

/**
 * Create HTTP server.
 */
const server = http.createServer(function(req, res) {
  let reqUrl = req.url;
  if(reqUrl.includes('favicon')) {
    res.statusCode = 200;
    res.write('');
    return res.end();
  }

  let method = req.method;

  let found = false;
  let statusCode = 200;
  let resBody = '';
  res.setHeader('Cache-Control', 'no-cache');

  if(method === 'POST') {
    if(reqUrl === '/songstart') {
      resBody = 'ok';
      found = true;
      broadcastUpdate();
    }
    else if (reqUrl == '/battery') {
      resBody = 'ok';
      found = true;
      batteryStats();
    }
  }
  else if(method === 'GET') {
    if(reqUrl === '/stats') {
      found = true;
      resBody = JSON.stringify({ stats: pb.readStatsSync(), battery: bs.getCurrentStats() });
      res.setHeader('Content-Type', 'application/json; charset=utf-8');
    }
  }

  if(!found) {
    res.statusCode = 404;
  } else {
    res.statusCode = statusCode;
  }

  debug(res.statusCode + ' ' + method + ': ' + reqUrl);

  res.write(resBody);
  return res.end();
});

/**
 * Listen on provided port, on all network interfaces.
 */
server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

wss = new WebSocketServer({ server: server });
wss.broadcast = function broadcast(data) {
  wss.clients.forEach(function each(client) {
    client.send(data);
  });
};

const statsRequireUpdate = function statsRequireUpdate(freshStats) {
  if(!freshStats){ return false; }
  if(!lastStats){ return true; }
  return !(freshStats.title == lastStats.title &&
     freshStats.stopped == !lastStats.running &&
     freshStats.paused == lastStats.paused);
};

const batteryStatsRequireUpdate = function batteryStatsRequireUpdate(s) {
  if(!s){ return false; }
  if(!lastBatteryStats){ return true; }
  return !(s.has_battery == lastBatteryStats.has_battery &&
           s.percentage == lastBatteryStats.percentage &&
           s.is_charging == lastBatteryStats.is_charging);
};

const broadcastStats = function broadcastStats() {
  pb.running();
  let stats = pb.readStatsSync();
  let isRunning = !pb.stopped;

  if(statsRequireUpdate(stats)) {
    lastStats = stats;
    lastStats.running = isRunning;
    wss.broadcast(JSON.stringify({ event: 'current-stats', stats: stats, running: isRunning }));
  }
};

const broadcastIntervalId = setInterval(broadcastStats, 500);

let batteryStatsIntervalId;
const batteryStats = function batteryStats() {
  bs.getBatteryStats(function(err, stats){
    if(err) {
      console.error(err);
      debug('Battery stats error', err);
      clearInterval(batteryStatsIntervalId);
    }
  });
};
batteryStatsIntervalId = setInterval(batteryStats, 500);

wss.on('connection', function connection(ws) {
  let guid = generateGUID();
  ws.send(JSON.stringify({
    event: 'connected',
    id: guid,
    ts: Date.now().toString(),
    stations: pb.readStationsSync(),
    running: pb.running()
  }));

  ws.send(JSON.stringify({
    event: 'battery-stats',
    id: guid,
    ts: Date.now().toString(),
    stats: lastBatteryStats
  }));

  ws.on('open', function open() {
    ws.send(Date.now().toString(), { mask: true });
  });

  ws.on('close', function () {

  });

  ws.on('message', function(data, flags) {
    let json = JSON.parse(data);
    let event = json.event;

    if(event === 'current-status') {
      let stats = pb.readStatsSync();
      let isRunning = !pb.stopped;
      ws.send(JSON.stringify({ event: 'current-stats', stats: stats, running: isRunning }));
    }
    else if(event === 'skip') {
      pb.skip(function(err){
        if(err){ console.error(err); }
      });
    }
    else if(event === 'like') {
      pb.like(function(err){
        if(err){ console.error(err); }
      });
    } else if(event === 'ban') {
      pb.ban(function(err){
        if(err){ console.error(err); }
      });
    }
    else if(event === 'pause-toggle') {
      pb.pauseToggle(function(err){
        if(err){ console.error(err); }
      });
    }
    else if(event === 'change-station') {
      let station = json.data.stationName;
      if(!station) { console.error('No station to change to', json); return; }

      pb.changeStation(station, function(err){
        if(err){ console.error(err); }
      });
    }
    else if(event === 'next-station') {
      pb.nextStation(function(err){
        if(err){ console.error(err); }
      });
    }
    else if(event === 'start') {
      startPianoBar();
    }
    else if(event === 'stop') {
      stopPianoBar();
    }
    else if(event === 'start-stop') {
      if(pb.stopped) {
        startPianoBar();
      } else {
        stopPianoBar();
      }
    }
  });
});

/**
 * Normalize a port into a number, string, or false.
 */
function normalizePort(val) {
  let port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */
function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  let bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */
function onListening() {
  let addr = server.address();
  let bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}

function shutdown() {
  stopPianoBar();
}

process.on('exit', function(){
  debug('Shutting down...');
  shutdown();
  process.exit(0);
});

process.on('SIGINT', function(){
  debug('Shutting down due to interruption...');
  shutdown();
  process.exit(0);
});

process.on('uncaughtException', function(e){
  console.error('Shutting down due to uncaught exception...');
  console.error(e.message);
  console.error(e.stack);
  debug('UncaughtException: ' + e.message);
  debug(e.stack);
  process.abort();
});
